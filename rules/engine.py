"""
Risk and Decision Rules Engine.
Implements deterministic rules to make final BUY/AVOID decisions.

This engine:
- Takes ML output (probability, trend)
- Applies risk rules
- Computes entry, stop-loss, and target prices
- Returns the final trading decision

The engine is DETERMINISTIC - same inputs always produce same outputs.
"""

import logging
from typing import Dict, Optional
from dataclasses import dataclass, asdict
from enum import Enum

import sys
sys.path.insert(0, str(__file__).rsplit("\\", 2)[0])
from config import RISK_CONFIG, TARGET_THRESHOLDS

logger = logging.getLogger(__name__)


class Decision(str, Enum):
    """Trading decision enum."""
    BUY = "BUY"
    AVOID = "AVOID"


@dataclass
class TradingPlan:
    """
    Complete trading plan generated by the rules engine.
    """
    decision: str
    confidence: int  # 0-100
    entry_price: float
    stop_loss: float
    target_price: float
    risk_reward_ratio: float
    position_risk_pct: float  # Risk per trade as percentage
    
    # Supporting data
    reasons: list  # Reasons for the decision
    warnings: list  # Any warnings/caveats
    
    # ML outputs (for transparency)
    ml_probability: float
    ml_trend: str
    ml_expected_move: float
    
    def to_dict(self) -> dict:
        """Convert to dictionary."""
        return asdict(self)


class RulesEngine:
    """
    Deterministic rules engine for trading decisions.
    
    Rules:
    1. Probability < 0.55 → AVOID
    2. Price below SMA 50 → AVOID (unless strong bullish signal)
    3. RSI > 80 (overbought) → AVOID or reduce confidence
    4. RSI < 20 (oversold) → Potential bounce, consider context
    5. Risk per trade ≤ 1.5%
    
    Computes:
    - Entry price (current price or slight improvement)
    - Stop-loss (~2% below entry)
    - Target (horizon-scaled, typically 2-3x stop-loss distance)
    """
    
    def __init__(self, config: Optional[dict] = None):
        """
        Initialize the rules engine.
        
        Args:
            config: Risk configuration (uses defaults if not provided)
        """
        self.config = config or RISK_CONFIG
        
    def evaluate(
        self, 
        ml_output: Dict,
        horizon: int,
        latest_price: float
    ) -> TradingPlan:
        """
        Evaluate ML output and generate trading plan.
        
        Args:
            ml_output: Dictionary from StockPredictor.predict()
            horizon: Trading horizon in days
            latest_price: Current stock price
            
        Returns:
            TradingPlan with decision and price levels
        """
        probability = ml_output["probability"]
        trend = ml_output["trend"]
        expected_move = ml_output["expected_move"]
        features = ml_output.get("features", {})
        
        reasons = []
        warnings = []
        
        # Initialize decision as BUY
        decision = Decision.BUY
        confidence = self._calculate_base_confidence(probability)
        
        # Rule 1: Probability threshold
        min_prob = self.config["min_probability"]
        if probability < min_prob:
            decision = Decision.AVOID
            reasons.append(f"Model probability ({probability:.1%}) below threshold ({min_prob:.1%})")
            confidence = int(probability * 100)
        else:
            reasons.append(f"Model probability ({probability:.1%}) above threshold")
        
        # Rule 2: Price relative to SMA 50
        above_sma_50 = features.get("above_sma_50", True)
        price_to_sma = features.get("price_to_sma_50_pct", 0)
        
        if not above_sma_50:
            if probability < 0.60:  # Need stronger signal when below SMA
                decision = Decision.AVOID
                reasons.append(f"Price below SMA 50 ({price_to_sma:.1f}% deviation)")
                confidence = min(confidence, 40)
            else:
                warnings.append(f"Price below SMA 50 - higher risk")
                confidence = min(confidence, 55)
        
        # Rule 3: RSI analysis
        rsi = features.get("rsi", 50)
        
        if rsi > 80:
            warnings.append(f"RSI overbought ({rsi:.1f}) - potential reversal risk")
            confidence = min(confidence, 50)
            if probability < 0.60:
                decision = Decision.AVOID
                reasons.append(f"RSI overbought ({rsi:.1f}) with moderate probability")
        elif rsi < 20:
            warnings.append(f"RSI oversold ({rsi:.1f}) - potential bounce")
            # Don't automatically change decision, but note it
        
        # Rule 4: Volatility check
        volatility = features.get("volatility", 20)
        if volatility > 50:  # High volatility
            warnings.append(f"High volatility ({volatility:.1f}%) - increased risk")
            confidence = min(confidence, confidence - 5)
        
        # Rule 5: Trend alignment
        if trend == "bearish":
            if decision == Decision.BUY:
                decision = Decision.AVOID
                reasons.append(f"Bearish trend signal")
        elif trend == "bullish":
            reasons.append(f"Bullish trend alignment")
        
        # Calculate price levels
        entry_price, stop_loss, target_price = self._calculate_price_levels(
            latest_price, horizon, expected_move, decision
        )
        
        # Calculate risk metrics
        risk_pct = abs(entry_price - stop_loss) / entry_price * 100
        reward_pct = abs(target_price - entry_price) / entry_price * 100
        risk_reward = reward_pct / risk_pct if risk_pct > 0 else 0
        
        # Final confidence adjustment
        confidence = max(0, min(100, confidence))
        
        # Add summary reason
        if decision == Decision.BUY:
            reasons.insert(0, f"Favorable conditions for {horizon}-day hold")
        else:
            reasons.insert(0, f"Unfavorable conditions - recommend avoiding")
        
        # Standard disclaimer as warning
        warnings.append("This is not financial advice. Always do your own research.")
        
        plan = TradingPlan(
            decision=decision.value,
            confidence=confidence,
            entry_price=round(entry_price, 2),
            stop_loss=round(stop_loss, 2),
            target_price=round(target_price, 2),
            risk_reward_ratio=round(risk_reward, 2),
            position_risk_pct=round(risk_pct, 2),
            reasons=reasons,
            warnings=warnings,
            ml_probability=probability,
            ml_trend=trend,
            ml_expected_move=expected_move,
        )
        
        logger.info(f"Rules evaluation: {decision.value} with {confidence}% confidence")
        
        return plan
    
    def _calculate_base_confidence(self, probability: float) -> int:
        """
        Calculate base confidence from ML probability.
        
        Maps probability to a more interpretable confidence score.
        """
        if probability >= 0.70:
            return 75
        elif probability >= 0.60:
            return 65
        elif probability >= 0.55:
            return 55
        elif probability >= 0.50:
            return 45
        else:
            return int(probability * 100)
    
    def _calculate_price_levels(
        self,
        current_price: float,
        horizon: int,
        expected_move: float,
        decision: Decision
    ) -> tuple:
        """
        Calculate entry, stop-loss, and target prices.
        
        Args:
            current_price: Current stock price
            horizon: Trading horizon
            expected_move: Expected percentage move from ML
            decision: BUY or AVOID decision
            
        Returns:
            Tuple of (entry, stop_loss, target)
        """
        # Entry price: current price (for market order)
        entry_price = current_price
        
        # Stop-loss: ~2% below entry (configurable)
        stop_loss_pct = self.config["default_stop_loss_pct"]
        stop_loss = entry_price * (1 - stop_loss_pct)
        
        # Target: based on horizon and risk-reward
        target_multiplier = self.config["target_multipliers"].get(horizon, 2.5)
        target_distance = (entry_price - stop_loss) * target_multiplier
        target_price = entry_price + target_distance
        
        # Adjust target based on expected move if it's more conservative
        if expected_move > 0:
            expected_target = entry_price * (1 + expected_move / 100)
            # Use the more conservative of the two
            target_price = min(target_price, expected_target * 1.1)
        
        # For AVOID decisions, still provide levels for reference
        # but they represent potential downside
        if decision == Decision.AVOID:
            # Keep same calculation but label appropriately
            pass
        
        return entry_price, stop_loss, target_price
    
    def validate_plan(self, plan: TradingPlan) -> bool:
        """
        Validate a trading plan meets all risk criteria.
        
        Args:
            plan: Trading plan to validate
            
        Returns:
            True if plan is valid
        """
        # Check risk per trade
        max_risk = self.config["max_risk_per_trade"] * 100
        if plan.position_risk_pct > max_risk:
            logger.warning(f"Position risk {plan.position_risk_pct}% exceeds max {max_risk}%")
            return False
        
        # Check risk-reward ratio (minimum 1.5:1 for BUY)
        if plan.decision == Decision.BUY.value and plan.risk_reward_ratio < 1.5:
            logger.warning(f"Risk-reward ratio {plan.risk_reward_ratio} below minimum 1.5")
            return False
        
        # Check confidence
        if plan.decision == Decision.BUY.value and plan.confidence < 50:
            logger.warning(f"Confidence {plan.confidence}% too low for BUY")
            return False
        
        return True


# Quick test
if __name__ == "__main__":
    logging.basicConfig(level=logging.INFO)
    
    engine = RulesEngine()
    
    # Test with sample ML output
    ml_output = {
        "probability": 0.65,
        "expected_move": 4.0,
        "trend": "bullish",
        "features": {
            "rsi": 55,
            "above_sma_50": True,
            "price_to_sma_50_pct": 2.5,
            "volatility": 25,
        }
    }
    
    plan = engine.evaluate(ml_output, horizon=7, latest_price=1500.0)
    
    print("\nTrading Plan:")
    print(f"  Decision: {plan.decision}")
    print(f"  Confidence: {plan.confidence}%")
    print(f"  Entry: ₹{plan.entry_price}")
    print(f"  Stop-Loss: ₹{plan.stop_loss}")
    print(f"  Target: ₹{plan.target_price}")
    print(f"  Risk/Reward: {plan.risk_reward_ratio}")
    print(f"  Position Risk: {plan.position_risk_pct}%")
    print(f"\nReasons: {plan.reasons}")
    print(f"Warnings: {plan.warnings}")
    
    # Test AVOID scenario
    print("\n" + "="*50)
    print("Testing AVOID scenario:")
    
    ml_output_avoid = {
        "probability": 0.45,
        "expected_move": -2.0,
        "trend": "bearish",
        "features": {
            "rsi": 35,
            "above_sma_50": False,
            "price_to_sma_50_pct": -5.0,
            "volatility": 40,
        }
    }
    
    plan_avoid = engine.evaluate(ml_output_avoid, horizon=7, latest_price=1500.0)
    
    print(f"\nDecision: {plan_avoid.decision}")
    print(f"Confidence: {plan_avoid.confidence}%")
    print(f"Reasons: {plan_avoid.reasons}")
